{"version":3,"file":"static/js/219.8863feac.chunk.js","mappings":"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","sources":["../node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js","pages/Charts/Bar.jsx","../node_modules/@syncfusion/ej2-charts/src/chart/series/column-series.js"],"sourcesContent":["/* eslint-disable jsdoc/require-returns */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\nimport { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\n * `DataLabel` module is used to render data label for the data point.\n */\nvar DataLabel = /** @class */ (function () {\n    /**\n     * Constructor for the data label module.\n     *\n     * @private\n     */\n    function DataLabel(chart) {\n        this.errorHeight = 0;\n        this.chart = chart;\n    }\n    DataLabel.prototype.initPrivateVariables = function (series, marker) {\n        var transform = '';\n        var clipPath = '';\n        var render = series.chart.renderer;\n        var index = (series.index === undefined) ? series.category : series.index;\n        if (series.chart.chartAreaType === 'Cartesian') {\n            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';\n            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n        }\n        if (marker.dataLabel.visible) {\n            series.shapeElement = render.createGroup({\n                'id': this.chart.element.id + 'ShapeGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n            });\n            series.textElement = render.createGroup({\n                'id': this.chart.element.id + 'TextGroup' + index,\n                'transform': transform,\n                'clip-path': clipPath\n            });\n        }\n        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;\n        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n        this.calculateErrorHeight(series, series.marker.dataLabel.position);\n        this.chartBackground = this.chart.chartArea.background === 'transparent' ?\n            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n    };\n    DataLabel.prototype.calculateErrorHeight = function (series, position) {\n        if (!series.errorBar.visible) {\n            return null;\n        }\n        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n            var direction = series.errorBar.direction;\n            var positiveHeight = this.chart.errorBarModule.positiveHeight;\n            var negativeHeight = this.chart.errorBarModule.negativeHeight;\n            if (this.isRectSeries(series)) {\n                if (position === 'Top' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Outer' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Plus') {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n            else {\n                if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {\n                        this.errorHeight = positiveHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n                if (position === 'Bottom' || position === 'Auto') {\n                    if (direction === 'Both' || direction === 'Minus') {\n                        this.errorHeight = negativeHeight;\n                    }\n                    else {\n                        this.errorHeight = 0;\n                    }\n                }\n            }\n        }\n        else {\n            this.errorHeight = 0;\n        }\n    };\n    DataLabel.prototype.isRectSeries = function (series) {\n        return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea';\n    };\n    /**\n     * Render the data label for series.\n     *\n     * @returns {void}\n     */\n    DataLabel.prototype.render = function (series, chart, dataLabel) {\n        // initialize the private variable\n        this.initPrivateVariables(series, series.marker);\n        var rect;\n        var labelLocation = { x: 0, y: 0 };\n        var rgbValue;\n        var contrast;\n        var argsData;\n        var border;\n        var textSize;\n        var angle;\n        var degree;\n        this.inverted = chart.requireInvertedAxis;\n        this.yAxisInversed = series.yAxis.isAxisInverse;\n        var redraw = chart.redraw;\n        var isDataLabelOverlap = false;\n        var coordinatesAfterRotation = [];\n        var templateId = chart.element.id + '_Series_' +\n            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n        var element = createElement('div', {\n            id: templateId\n        });\n        var visiblePoints = getVisiblePoints(series);\n        var point;\n        var rectCenterX;\n        var rectCenterY;\n        // Data label point iteration started\n        for (var i = 0; i < visiblePoints.length; i++) {\n            point = visiblePoints[i];\n            if (!dataLabel.showZero && ((point.y !== 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {\n                return null;\n            }\n            this.margin = dataLabel.margin;\n            var labelText = [];\n            var labelLength = void 0;\n            var xPos = void 0;\n            var yPos = void 0;\n            var xValue = void 0;\n            var yValue = void 0;\n            var isRender = true;\n            var clip = series.clipRect;\n            var shapeRect = void 0;\n            isDataLabelOverlap = false;\n            angle = degree = dataLabel.angle;\n            border = { width: dataLabel.border.width, color: dataLabel.border.color };\n            var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));\n            if ((point.symbolLocations.length && point.symbolLocations[0]) ||\n                (series.type === 'BoxAndWhisker' && point.regions.length)) {\n                labelText = getLabelText(point, series, chart);\n                labelLength = labelText.length;\n                for (var i_1 = 0; i_1 < labelLength; i_1++) {\n                    argsData = {\n                        cancel: false, name: textRender, series: series,\n                        point: point, text: labelText[i_1], border: border,\n                        color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,\n                        textSize: measureText(labelText[i_1], dataLabel.font)\n                    };\n                    chart.trigger(textRender, argsData);\n                    if (!argsData.cancel) {\n                        this.fontBackground = argsData.color;\n                        this.isDataLabelShape(argsData);\n                        this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;\n                        if (argsData.template !== null) {\n                            this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\n                        }\n                        else {\n                            if (this.chart.useGroupingSeparator && Number(argsData.text)) {\n                                argsData.text = this.chart.intl.formatNumber(+argsData.text, {\n                                    useGrouping: this.chart.useGroupingSeparator\n                                });\n                            }\n                            textSize = measureText(argsData.text, dataLabel.font);\n                            rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1);\n                            // To check whether the polar radar chart datalabel intersects the axis label or not\n                            if (chart.chartAreaType === 'PolarRadar') {\n                                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\n                                    var rectRegion = _a[_i];\n                                    if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\n                                        isRender = false;\n                                        break;\n                                    }\n                                }\n                            }\n                            var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\n                            //let notOverlapping: boolean;\n                            if (dataLabel.enableRotation) {\n                                var rectCoordinates = this.getRectanglePoints(rect);\n                                rectCenterX = rect.x + (rect.width / 2);\n                                rectCenterY = (rect.y + (rect.height / 2));\n                                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\n                                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\n                                if (!isDataLabelOverlap) {\n                                    this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\n                                    var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n                                    for (var index = currentPointIndex; index >= 0; index--) {\n                                        if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&\n                                            this.chart.rotatedDataLabelCollections[index - 1] &&\n                                            isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                                            isDataLabelOverlap = true;\n                                            this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            else {\n                                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\n                            }\n                            if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\n                                chart.dataLabelCollections.push(actualRect);\n                                if (this.isShape) {\n                                    shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n                                    if (series.shapeElement) {\n                                        series.shapeElement.appendChild(shapeRect);\n                                    }\n                                }\n                                // Checking the font color\n                                rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n                                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                                xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;\n                                yPos = (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;\n                                labelLocation = { x: 0, y: 0 };\n                                if (angle !== 0 && dataLabel.enableRotation) {\n                                    // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                                    xValue = rectCenterX;\n                                    //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                                    // (dataLabel.margin.bottom) / 2;\n                                    yValue = rectCenterY;\n                                    degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n                                }\n                                else {\n                                    degree = 0;\n                                    xValue = rect.x;\n                                    yValue = rect.y;\n                                }\n                                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color ||\n                                    ((contrast >= 128 || series.type === 'Hilo') ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (element.childElementCount) {\n            if (!chart.enableCanvas) {\n                appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, \n                // eslint-disable-next-line @typescript-eslint/indent\n                false, 'x', 'y', null, '', false, false, null, chart.duration);\n            }\n            else {\n                getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n            }\n        }\n    };\n    /**\n     * Get rect coordinates\n     */\n    DataLabel.prototype.getRectanglePoints = function (rect) {\n        var loc1 = new ChartLocation(rect.x, rect.y);\n        var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n        var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n        return [loc1, loc2, loc3, loc4];\n    };\n    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n        for (var index = 0; index < rectCoordinates.length; index++) {\n            if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Render the data label template.\n     *\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        var clip = series.clipRect;\n        var childElement = createTemplate(createElement('div', {\n            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'\n                + point.index + (labelIndex ? ('_' + labelIndex) : ''),\n            styles: 'position: absolute;background-color:' + data.color + ';' +\n                getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n        }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n    };\n    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n        var elementRect = measureElementRect(childElement, redraw, isReactCallback);\n        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);\n        var clipWidth = 0;\n        var clipHeight = 0;\n        var isOverlap = false;\n        if (isReactCallback) {\n            isOverlap = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call\n            // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n            //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n            // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n        }\n        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';\n        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';\n        var rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n        childElement.style.color = dataLabel.font.color ||\n            ((Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000)) >= 128 ? 'black' : 'white');\n        if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) ||\n            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||\n            withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||\n            (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&\n            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&\n            parseFloat(childElement.style.left) >= hAxis.rect.x &&\n            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&\n            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n            appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n                this.doDataLabelAnimation(series, childElement);\n            }\n            else if (this.chart.enableCanvas) {\n                parentElement.appendChild(childElement);\n            }\n        }\n    };\n    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var location;\n        location = this.getLabelLocation(point, series, textSize, labelIndex);\n        var padding = 5;\n        var clipRect = series.clipRect;\n        // calculating alignment\n        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n            this.locationX = location.x;\n            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +\n                this.margin.bottom + this.margin.top + padding;\n            location.y = (dataLabel.position === 'Auto') ? location.y :\n                this.calculateAlignment(alignmentValue, location.y, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\n            // calculating position\n            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?\n                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :\n                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n            }\n        }\n        else {\n            this.locationY = location.y;\n            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n            location.x = dataLabel.position === 'Auto' ? location.x :\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n        }\n        var rect = calculateRect(location, textSize, this.margin);\n        // Checking the condition whether data Label has been exist the clip rect\n        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&\n            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||\n                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {\n            rect.x = rect.x < 0 ? padding : rect.x;\n            rect.y = (rect.y < 0) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)\n                - (clipRect.x + clipRect.width) + padding : 0;\n            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)\n                - (clipRect.y + clipRect.height) + padding : 0;\n            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        }\n        return rect;\n    };\n    // Calculation label location for polar column draw types\n    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n        var padding = 5;\n        var columnRadius;\n        var chartWidth = this.chart.availableSize.width;\n        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);\n        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n        if (labelIndex === 0) {\n            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        else {\n            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius\n                : point.regionData.radius;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        if (series.drawType.indexOf('Stacking') > -1) {\n            position = position === 'Outer' ? 'Top' : position;\n        }\n        else if (series.drawType.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        if (position === 'Outer') {\n            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :\n                columnRadius - 2 * padding - this.markerHeight;\n        }\n        else if (position === 'Middle') {\n            columnRadius = columnRadius / 2 + padding;\n            if (series.drawType === 'StackingColumn') {\n                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)\n                    + padding - (size.height / 2);\n            }\n        }\n        else if (position === 'Top') {\n            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :\n                columnRadius + 2 * padding + this.markerHeight;\n        }\n        else if (position === 'Bottom') {\n            columnRadius = 2 * padding;\n            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;\n        }\n        else {\n            if (labelIndex === 0) {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :\n                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n            }\n            else {\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n            }\n        }\n        columnRadius += (alignmentValue * alignmentSign);\n        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n        // To change x location based on text anchor for column and stackingcolumn chart\n        if (series.drawType === 'StackingColumn') {\n            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);\n        }\n        else if (series.drawType === 'Column') {\n            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :\n                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);\n        }\n        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n        return location;\n    };\n    /**\n     * Get the label location\n     */\n    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n        var location = new ChartLocation(0, 0);\n        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];\n        if (series.type === 'HiloOpenClose') {\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\n        }\n        var xAxis = series.xAxis;\n        var yAxis = series.yAxis;\n        var isInverted = series.chart.requireInvertedAxis;\n        if (series.type === 'BoxAndWhisker') {\n            this.markerHeight = 0;\n            switch (labelIndex) {\n                case 0:\n                    location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n                    break;\n                case 1:\n                    location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n                    break;\n                case 2:\n                    location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n                    break;\n                case 3:\n                    location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n                    break;\n                case 4:\n                    location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n                    break;\n                default: {\n                    location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n                    this.markerHeight = series.marker.height / 2;\n                    break;\n                }\n            }\n            if (isInverted) {\n                location.y = point.regions[0].y + (point.regions[0].height / 2);\n            }\n            else {\n                location.x = point.regions[0].x + (point.regions[0].width / 2);\n            }\n        }\n        else if (labelIndex === 0 || labelIndex === 1) {\n            location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n        }\n        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n            location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n        }\n        else if (isInverted) {\n            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };\n        }\n        else {\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\n        }\n        //Aligning the label at the beginning of the tick, when tick size is less than text size\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n            if (series.chart.requireInvertedAxis) {\n                var height = labelRegion.height;\n                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n            else {\n                var width = labelRegion.width;\n                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n        if (series.chart.chartAreaType === 'PolarRadar') {\n            return null;\n        }\n        var padding = 5;\n        var margin = this.margin;\n        var textLength = !this.inverted ? textSize.height : textSize.width;\n        var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 &&\n            (Math.abs(rect.height - textSize.height) < padding) ? 0 : padding);\n        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n            position = (position === 'Outer') ? 'Top' : position;\n        }\n        else if (series.type.indexOf('Range') > -1) {\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\n        }\n        else if (series.type === 'Waterfall') {\n            position = position === 'Auto' ? 'Middle' : position;\n        }\n        switch (position) {\n            case 'Bottom':\n                labelLocation = !this.inverted ?\n                    isMinus ? (labelLocation - rect.height + extraSpace + margin.top) :\n                        (labelLocation + rect.height - extraSpace - margin.bottom) :\n                    isMinus ? (labelLocation + rect.width - extraSpace - margin.left) :\n                        (labelLocation - rect.width + extraSpace + margin.right);\n                break;\n            case 'Middle':\n                labelLocation = labelLocation = !this.inverted ?\n                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :\n                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));\n                break;\n            case 'Auto':\n                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n                break;\n            default:\n                extraSpace += this.errorHeight;\n                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n                break;\n        }\n        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :\n            (labelLocation < rect.x || labelLocation > rect.x + rect.width);\n        this.fontBackground = check ?\n            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)\n            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;\n        var seriesLength = series.chart.series.length;\n        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {\n            var nextSeries = void 0;\n            var nextSeriesPoint = void 0;\n            for (var i = series.index + 1; i < seriesLength; i++) {\n                nextSeries = series.chart.series[i];\n                nextSeriesPoint = nextSeries.points[point.index];\n                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {\n                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||\n                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :\n                        nextSeries.interior) : this.fontBackground;\n                    break;\n                }\n            }\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n        var padding = 5;\n        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea')\n            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n        }\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n        switch (position) {\n            case 'Top':\n            case 'Outer':\n                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -\n                    this.errorHeight;\n                break;\n            case 'Bottom':\n                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +\n                    this.errorHeight;\n                break;\n            case 'Auto':\n                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n                break;\n        }\n        return labelLocation;\n    };\n    DataLabel.prototype.isDataLabelShape = function (style) {\n        this.isShape = (style.color !== 'transparent' || style.border.width > 0);\n        this.borderWidth = style.border.width;\n        if (!this.isShape) {\n            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\n        }\n    };\n    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n        var location;\n        var labelRect;\n        var isOverLap = true;\n        var position = 0;\n        var collection = this.chart.dataLabelCollections;\n        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n        while (isOverLap && position < finalPosition) {\n            var actualPosition = this.getPosition(position);\n            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n                actualPosition = 'Top';\n                position++;\n            }\n            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n            if (!this.inverted) {\n                labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n                isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n            }\n            else {\n                labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n                isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) ||\n                    labelRect.x + labelRect.width > series.clipRect.width;\n            }\n            position++;\n        }\n        return location;\n    };\n    // alignment calculation assigned here\n    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n        switch (alignment) {\n            case 'Far':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :\n                    (isMinus ? labelLocation - value : labelLocation + value);\n                break;\n            case 'Near':\n                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :\n                    (isMinus ? labelLocation + value : labelLocation - value);\n                break;\n            // eslint-disable-next-line no-self-assign\n            case 'Center':\n                labelLocation = labelLocation;\n                break;\n        }\n        return labelLocation;\n    };\n    //calculation for top and outer position of datalabel for rect series\n    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n        var margin = this.margin;\n        var top;\n        switch (series.type) {\n            case 'RangeColumn':\n            case 'RangeArea':\n            case 'SplineRangeArea':\n            case 'Hilo':\n                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                break;\n            case 'Candle':\n                top = (index === 0 || index === 2) && !this.yAxisInversed\n                    || (index === 1 || index === 3) && this.yAxisInversed;\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n                break;\n            case 'HiloOpenClose':\n                if (index <= 1) {\n                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\n                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n                }\n                else {\n                    if (this.yAxisInversed) {\n                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n                    }\n                    else {\n                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n                    }\n                }\n                break;\n            default:\n                if ((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) {\n                    location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight :\n                        location + extraSpace + margin.left + this.markerHeight;\n                }\n                else {\n                    location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight :\n                        location - extraSpace - margin.right - this.markerHeight;\n                }\n                break;\n        }\n        return location;\n    };\n    /**\n     * Updates the label location\n     */\n    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n        if (inside === void 0) { inside = false; }\n        if (!this.inverted) {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location - extraSpace - margin.bottom - this.markerHeight :\n                    location + extraSpace + margin.top + this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location + rect.height + extraSpace + margin.top + this.markerHeight :\n                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n            }\n        }\n        else {\n            if (top) {\n                location = (position === 'Outer' && !inside) ? location + extraSpace + margin.left + this.markerHeight :\n                    location - extraSpace - margin.right - this.markerHeight;\n            }\n            else {\n                location = (position === 'Outer' && !inside) ? location - rect.width - extraSpace - margin.right - this.markerHeight :\n                    location - rect.width + extraSpace + margin.left + this.markerHeight;\n            }\n        }\n        return location;\n    };\n    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n        var points = series.points;\n        var index = point.index;\n        var yValue = points[index].yValue;\n        var position;\n        var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n        var previousPoint = index > 0 ? points[index - 1] : null;\n        var yLocation;\n        var isOverLap = true;\n        var labelRect;\n        var isBottom;\n        var positionIndex;\n        var collection = this.chart.dataLabelCollections;\n        if (series.type === 'Bubble') {\n            position = 'Top';\n        }\n        else if (series.type.indexOf('Step') > -1) {\n            position = 'Top';\n            if (index) {\n                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)\n                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';\n            }\n        }\n        else if (series.type === 'BoxAndWhisker') {\n            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n                position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n            }\n            else if (labelIndex === 2 || labelIndex === 4) {\n                position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n            }\n            else {\n                isOverLap = false;\n                position = 'Middle';\n                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n            }\n        }\n        else {\n            if (index === 0) {\n                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||\n                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else if (index === points.length - 1) {\n                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||\n                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\n            }\n            else {\n                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n                    position = 'Top';\n                }\n                else if (!nextPoint.visible || !previousPoint) {\n                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?\n                        'Bottom' : 'Top';\n                }\n                else {\n                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));\n                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :\n                        intersectY < yValue ? 'Bottom' : 'Top';\n                }\n            }\n        }\n        isBottom = position === 'Bottom';\n        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n        while (isOverLap && positionIndex < 4) {\n            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n            labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n            isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect)\n                || (labelRect.y + labelRect.height) > series.clipRect.height;\n            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n            isBottom = false;\n        }\n        return yLocation;\n    };\n    /**\n     * Animates the data label.\n     *\n     * @param  {Series} series - Data label of the series gets animated.\n     * @returns {void}\n     */\n    DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n        var shapeElements = series.shapeElement.childNodes;\n        var textNode = series.textElement.childNodes;\n        var delay = series.animation.delay + series.animation.duration;\n        var duration = series.chart.animated ? series.chart.duration : 200;\n        var location;\n        var length = element ? 1 : textNode.length;\n        var tempElement;\n        for (var i = 0; i < length; i++) {\n            tempElement = textNode[i];\n            if (element) {\n                element.style.visibility = 'hidden';\n                templateAnimate(element, delay, duration, 'ZoomIn');\n            }\n            else {\n                location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                markerAnimate(tempElement, delay, duration, series, null, location, true);\n                if (shapeElements[i]) {\n                    tempElement = shapeElements[i];\n                    location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\n                    markerAnimate(tempElement, delay, duration, series, null, location, true);\n                }\n            }\n        }\n    };\n    DataLabel.prototype.getPosition = function (index) {\n        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);\n    };\n    /**\n     * Get module name.\n     */\n    DataLabel.prototype.getModuleName = function () {\n        // Returns the module name\n        return 'DataLabel';\n    };\n    /**\n     * To destroy the dataLabel for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    DataLabel.prototype.destroy = function () {\n        // Destroy method performed here\n    };\n    return DataLabel;\n}());\nexport { DataLabel };\n","import React from 'react';\r\nimport { ChartComponent, SeriesCollectionDirective, SeriesDirective, Inject, Legend, Category, Tooltip, ColumnSeries, DataLabel } from '@syncfusion/ej2-react-charts';\r\n\r\nimport { barCustomSeries, barPrimaryXAxis, barPrimaryYAxis } from '../../data/dummy';\r\nimport { ChartsHeader } from '../../components';\r\nimport { useStateContext } from '../../contexts/ContextProvider';\r\n\r\nconst Bar = () => {\r\n  const { currentMode } = useStateContext();\r\n\r\n  return (\r\n    <div className=\"m-4 md:m-10 mt-24 p-10 bg-white dark:bg-secondary-dark-bg rounded-3xl\">\r\n      <ChartsHeader category=\"Bar\" title=\"Olympic Medal Counts - RIO\" />\r\n      <div className=\" w-full\">\r\n        <ChartComponent\r\n          id=\"charts\"\r\n          primaryXAxis={barPrimaryXAxis}\r\n          primaryYAxis={barPrimaryYAxis}\r\n          chartArea={{ border: { width: 0 } }}\r\n          tooltip={{ enable: true }}\r\n          background={currentMode === 'Dark' ? '#33373E' : '#fff'}\r\n          legendSettings={{ background: 'white' }}\r\n        >\r\n          <Inject services={[ColumnSeries, Legend, Tooltip, Category, DataLabel]} />\r\n          <SeriesCollectionDirective>\r\n            {/* eslint-disable-next-line react/jsx-props-no-spreading */}\r\n            {barCustomSeries.map((item, index) => <SeriesDirective key={index} {...item} />)}\r\n          </SeriesCollectionDirective>\r\n        </ChartComponent>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Bar;\r\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-returns */\nimport { withInRange } from '../../common/utils/helper';\nimport { ColumnBase } from './column-base';\n/**\n * `ColumnSeries` Module used to render the column series.\n */\nvar ColumnSeries = /** @class */ (function (_super) {\n    __extends(ColumnSeries, _super);\n    function ColumnSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render Column series.\n     *\n     * @returns {void}\n     * @private\n     */\n    ColumnSeries.prototype.render = function (series) {\n        var rect;\n        var sideBySideInfo = this.getSideBySideInfo(series);\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        var argsData;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var pointColumn = _a[_i];\n            pointColumn.symbolLocations = [];\n            pointColumn.regions = [];\n            if (pointColumn.visible && withInRange(series.points[pointColumn.index - 1], pointColumn, series.points[pointColumn.index + 1], series)) {\n                rect = this.getRectangle(pointColumn.xValue + sideBySideInfo.start, pointColumn.yValue, pointColumn.xValue + sideBySideInfo.end, origin, series);\n                rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : rect.width;\n                rect.x = series.columnWidthInPixel ? rect.x - (((series.columnWidthInPixel / 2) * series.rectCount) -\n                    (series.columnWidthInPixel * series.index)) : rect.x;\n                var color = series.category === 'Indicator' ? pointColumn.color : series.interior;\n                argsData = this.triggerEvent(series, pointColumn, color, { width: series.border.width, color: series.border.color });\n                if (!argsData.cancel) {\n                    this.updateSymbolLocation(pointColumn, rect, series);\n                    this.drawRectangle(series, pointColumn, rect, argsData);\n                }\n            }\n        }\n        this.renderMarker(series);\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     */\n    ColumnSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    /**\n     * Get module name.\n     */\n    ColumnSeries.prototype.getModuleName = function () {\n        return 'ColumnSeries';\n        /**\n         * return the module name\n         */\n    };\n    /**\n     * To destroy the column series.\n     *\n     * @returns {void}\n     * @private\n     */\n    ColumnSeries.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    return ColumnSeries;\n}(ColumnBase));\nexport { ColumnSeries };\n"],"names":["DataLabel","chart","this","errorHeight","prototype","initPrivateVariables","series","marker","transform","clipPath","render","renderer","index","undefined","category","chartAreaType","clipRect","x","y","element","id","dataLabel","visible","shapeElement","createGroup","textElement","markerHeight","type","height","commonId","calculateErrorHeight","position","chartBackground","chartArea","background","themeStyle","errorBar","direction","positiveHeight","errorBarModule","negativeHeight","isRectSeries","isTransposed","rect","rgbValue","contrast","argsData","border","textSize","angle","degree","labelLocation","inverted","requireInvertedAxis","yAxisInversed","yAxis","isAxisInverse","point","rectCenterX","rectCenterY","redraw","isDataLabelOverlap","coordinatesAfterRotation","templateId","createElement","visiblePoints","getVisiblePoints","i","length","showZero","emptyPointSettings","mode","margin","labelText","labelLength","xPos","yPos","xValue","yValue","isRender","clip","shapeRect","width","color","argsFont","extend","getValue","font","symbolLocations","regions","getLabelText","i_1","cancel","name","textRender","text","fill","template","location","measureText","trigger","fontBackground","isDataLabelShape","createDataLabelTemplate","useGroupingSeparator","Number","intl","formatNumber","useGrouping","calculateTextPosition","_i","_a","chartAxisLayoutPanel","visibleAxisLabelRect","rectRegion","isOverlap","Rect","actualRect","enableRotation","rectCoordinates","getRectanglePoints","getRotatedRectangleCoordinates","isDataLabelOverlapWithChartBound","rotatedDataLabelCollections","push","currentPointIndex","isRotatedRectIntersect","isCollide","dataLabelCollections","labelIntersectAction","isShape","drawRectangle","RectOption","opacity","rx","ry","Int32Array","appendChild","convertHexToColor","colorNameToHex","Math","round","r","g","b","left","top","TextOption","duration","enableCanvas","childElementCount","getElement","appendChildElement","ChartLocation","withInBounds","initialClipRect","parentElement","data","labelIndex","right","bottom","childElement","createTemplate","styles","getFontStyle","calculateTemplateLabelSize","isReactCallback","elementRect","measureElementRect","style","vAxis","xAxis","hAxis","seriesType","withIn","visibleRange","indexOf","stackedValues","endValues","parseFloat","animation","enable","animateSeries","doDataLabelAnimation","labelRegion","getLabelLocation","locationY","alignmentValue","borderWidth","calculateAlignment","alignment","calculateRectPosition","locationX","calculatePathPosition","calculatePolarRectPosition","calculateRect","size","columnRadius","chartWidth","availableSize","alignmentSign","regionData","startAngle","PI","endAngle","radius","innerRadius","drawType","cos","sin","isInverted","getPoint","median","maximum","minimum","upperQuartile","lowerQuartile","outliers","isMinus","textLength","extraSpace","abs","calculateRectActualPosition","calculateTopAndOuterPosition","check","interior","seriesLength","nextSeries","nextSeriesPoint","points","calculatePathActualPosition","labelRect","isOverLap","collection","finalPosition","actualPosition","getPosition","value","updateLabelLocation","inside","markerSize","yLocation","isBottom","positionIndex","nextPoint","previousPoint","slope","intersectY","tempElement","shapeElements","childNodes","textNode","delay","animated","visibility","templateAnimate","getAttribute","markerAnimate","getModuleName","destroy","Bar","currentMode","useStateContext","_jsxs","className","children","_jsx","ChartsHeader","title","ChartComponent","primaryXAxis","barPrimaryXAxis","primaryYAxis","barPrimaryYAxis","tooltip","legendSettings","Inject","services","ColumnSeries","Legend","Tooltip","Category","SeriesCollectionDirective","barCustomSeries","map","item","SeriesDirective","__extends","extendStatics","d","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","create","_super","apply","arguments","sideBySideInfo","getSideBySideInfo","origin","max","min","pointColumn","withInRange","getRectangle","start","end","columnWidthInPixel","rectCount","triggerEvent","updateSymbolLocation","renderMarker","doAnimation","animate","ColumnBase"],"sourceRoot":""}